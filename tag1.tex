\subtitle{Tag eins - Was ist Haskell} 
\date{24.03.2014}

\begin{frame}[plain]
\titlepage
\end{frame}

\section{Organisatorisches}
\begin{frame}
\frametitle{Organisatorisches}
\begin{block}{\vspace*{-3ex}}
	\begin{itemize}
	  \item Jeden Wochentag vom Mo, 24.03.2014 bis Fr, 28.03.2014 im Raum IZ 261.
	  \item 10:00 bis 16:00 Raumreservierung
	  \item 10:00 bis 11:30 theoretische Einführung in Haskell
	  \item 11:30 bis 12:30 Mittagspause
	  \item 12:30 bis ca. 15:30 praktische Übungen
	\end{itemize}
\end{block}
\end{frame}


\begin{frame}
\frametitle{Organisatorisches}
\begin{block}{\vspace*{-3ex}}
	\begin{itemize}
	  \item Theorie (jetzt)\\
	  		Umsetzung des Stoffs der Vorlesung in Haskell
	  \item Übungen (nachher)\\
	  		praktisches Arbeiten mit Haskell über den GHCi
	\end{itemize}
\end{block}
\end{frame}

\begin{frame}
\frametitle{Quellen}
\begin{block}{\vspace*{-3ex}}	
	\begin{itemize}
	  \item Algorithmieren und Programmieren\\ Vorlesung von Prof. Dr. Petra Hofstedt (BTU)
	  \item Moderne Funktionale Programmierung \\ Vorlesung von Prof. Dr. Petra Hofstedt (BTU)
	  \item Eine Einführung in die funktionale Programmierung mit Haskell \\ Übungsskript zu unserer Vorlesung
	  \item Haskell - Intensivkurs
	\end{itemize}
\end{block}
\end{frame}

\section{Das funktionale Paradigma}
\begin{frame}
\frametitle{Paradigmen}
\begin{block}{\vspace*{-3ex}}
\begin{itemize}
  \item Programmierparadigma\\
		generelle Sicht bei der Modellierung und Lösung eines Problems
  \item Klassische Unterscheidung
  \begin{itemize}
    \item Imperative Sprachen\\
    	 \textbf{"`Wie"'} findet die Lösung statt\\
    	 Folge von Anweisungen zur Problemlösung  
    \item Deklarative Sprachen \\
    	 \textbf{"`Was"'} ist die Lösung \\
    	 deklarative Beschreibung der Lösung bzw. des Problems
  \end{itemize}
\end{itemize}
\end{block}
\end{frame}

\begin{frame}
\frametitle{Paradigmen}
\begin{center}
\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=2.5cm, xscale=2]
\node (Paradigmen)	{Paradigmen};
\node (imperativ) [below left of = Paradigmen]	{imperativ};
\node (prozedural) [below left of = imperativ]	{prozedural};
\node (oo) [below of = Paradigmen]	{objekt-orientiert};
\node (deklarativ) [below right of = Paradigmen]	{deklarativ};
\node (fl) [below left of = deklarativ]	{funktional-logisch};
\node (cl) [below right of = deklarativ]	{constraint-logisch};
\node (funktional) [below left of = fl]	{\textbf{funktional}};
\node (logisch) [right of = funktional]	{logisch};
\node (cb) [right of = logisch]	{constraint-basiert};

\path	(Paradigmen)	edge node { } (imperativ)
							edge node { } (deklarativ)
			(imperativ)		edge node { } (prozedural)
			(deklarativ)	edge node { } (fl)
							edge node { } (cl)
			(fl)			edge node { } (funktional)
							edge node { } (logisch)
			(cl)			edge node { } (logisch)
							edge node { } (cb);

\path[dashed]	(Paradigmen)	edge node { } (oo)
			(imperativ)		edge node { } (oo);		
\end{tikzpicture}
\end{center}
\end{frame}

\begin{frame}
\frametitle{Funktionale Paradigma}
\begin{block}{\vspace*{-3ex}}
\begin{itemize}
  \item Hohes Abstraktionsniveau \\ 
  Klare Darstellung der Programmiertechniken und Algorithmen,
d.h. Konzentration auf die Konzepte statt auf die Sprache.
  \item Klare, elegante und kompakte Programme \\ 
  kurze Entwicklungszeiten, lesbare Programme.
  \item Keine Seiteneffekte \\ 
  erleichtert Verstehen, Optimierung, Verifikation.
  \item Saubere theoretische Fundierung \\ 
  ermöglicht Verifikation und erleichtert formale Argumentation über Programme.
\end{itemize}
\end{block}
\end{frame}

\section{Haskell}
\begin{frame}
\frametitle{Haskell}
\begin{block}{\vspace*{-3ex}}
\begin{itemize}
  \item 1990 als Haskell 1.0 veröffentlicht
  \item Aktuelle Version Haskell 2010
  \item An Haskell 2014 (Preview) wird "`gearbeitet"'
\end{itemize}
\end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{Hello World} 
\begin{lstlisting}
module Main where
 
main :: IO ()
main = putStrLn "Hello, World!"
\end{lstlisting}
\pause
\begin{block}{Ausgabe}
\begin{center}
Hello, World!
\end{center}
\end{block}
\pause
\begin{center}
weiteres in den Übungen
\end{center}
\end{frame}

\begin{frame}
\frametitle{Haskell Compiler}
\begin{block}{\vspace*{-3ex}}
\begin{itemize}
  \item Hugs (Haskell User's Gofer System) \\ implementiert Haskell 98 \\ seit ca 6 Jahren nicht weiterentwickelt
  \item Yhc (York Haskell Compiler) \\ implementiert Haskell 98 \\ Projekt eingestellt
  \item GHC (Glasgow Haskell Compiler) \\ implementiert Haskell 98 / 2010 \\ weit verbreitster Haskell Compiler \\ 
  besitzt den GHCi als Haskell Interpreter \\ in den Übungen werden wir hauptsächlich mit dem Interpreter arbeiten
\end{itemize}
\end{block}
\end{frame}

\begin{frame}
\frametitle{Glasgow Haskell Compiler}
\begin{block}{\vspace*{-3ex}}
\begin{itemize}
  \item Original Prototyp '89 in LML (Lazy ML) 
  \item Bei der Entwicklung von Haskell in Haskell neu geschrieben ('89)
  \item Nur kleine Teile in C bzw. C-- (C verwandte Sprache zur Nutzung als Zwischencode)
  \item Erweitert den Haskell Standard um noch nicht standardisierte Erweiterungen
  \item Plattform und Architektur unabhängig
\end{itemize}
\end{block}
\end{frame}

\begin{frame}
\frametitle{Laufzeitumgebung}
\begin{block}{\vspace*{-3ex}}
\begin{itemize}
  \item Wenn das Programm in Maschinencode übersetzt wurde, wird keine externe Laufzeitumgebung benötigt (nativer Code)\\
  		die "`Laufzeitumgebung"' wird mit in das Programm gepackt
  \item Bei Benutzung des Interpreters wird dieser als Laufzeitumgebung verwendet.
\end{itemize}
\end{block}
\end{frame}

\begin{frame}
\frametitle{Interne Funktionsweise}
\begin{block}{\vspace*{-3ex}}
\begin{itemize}
  \item Erzeugung von Zwischencode "`C--"'
  \item C-- ist wie C-Code jedoch "`etwas"' anders
  \item Dieser Code wird optimiert und weiter compiliert
  \item "`-fasm"' erzeugt Maschinencode (Standard)
  \item "`-fvia-C"' erzeugt C-Code aus C--\\
  		seit Version 7.0 nicht mehr unterstützt
  \item "`-fllvm"' nutzt den LLVM als Backend-Compiler
\end{itemize}
\end{block}
\end{frame}

\begin{frame}
\frametitle{Interne Funktionsweise}
\begin{figure}
\centering
\includegraphics*[scale=0.4]{images/HscPipe2_1}
\caption{Compiler Teil 1 \copyright haskell.org}
\end{figure}
\end{frame}


\begin{frame}
\frametitle{Interne Funktionsweise}
\begin{figure}
\centering
\includegraphics[scale=0.4]{images/HscPipe2_2.png}
\caption{Compiler Teil 2 \copyright haskell.org}
\end{figure}
\end{frame}

\begin{frame}
\frametitle{Interne Funktionsweise}
\begin{figure}
\centering
\includegraphics[scale=0.4]{images/HscPipe2_3.png}
\caption{Compiler Teil 3 \copyright haskell.org}
\end{figure}
\end{frame}

\begin{frame}
\frametitle{Interne Funktionsweise}
\begin{figure}
\centering
\includegraphics[scale=0.4]{images/HscPipe2_4.png}
\caption{Compiler Teil 4 \copyright haskell.org}
\end{figure}
\end{frame}

\section{Semantische Grundbegriffe}

\subsection{Namen und Attribute}
\begin{frame}
\frametitle{Namen und Attribute}
\begin{block}{\vspace*{-3ex}}
\begin{itemize}
  \item Alle endlichen ASCII-Strings außer:
  \\ \lstinline|case|, \lstinline|class|, \lstinline|data|, \lstinline|default|, \lstinline|deriving|, \lstinline|do|, \lstinline|else|, \lstinline|if|, \lstinline|import|, \lstinline|in|, \lstinline|infix|, \lstinline|infixl|, \lstinline|infixr|, \lstinline|instance|, \lstinline|let|, \lstinline|module|, \lstinline|newtype|, \lstinline|of|, \lstinline|then|, \lstinline|type|, \lstinline|where|
  \item Bezeichner sind case-sensitiv. (\lstinline|pLus| $\neq$ \lstinline|plus|) 
  \item \lstinline|_| (Unterstrich) ist der Platzhalter
  \item Module beginnen mit einem Großbuchstaben
  \item Funktionen mit einem Kleinbuchstaben
\end{itemize}
\end{block}
\end{frame}

\subsection{Variablen und Konstanten}
\begin{frame}
\frametitle{Variablen}
\begin{block}{\vspace*{-3ex}}
\begin{itemize}
  \item Globale Variablen existieren nicht
  \item Lokale Variablen existieren nur in Funktionen als Teilergebnis
\end{itemize}
\end{block}
\end{frame}

\begin{frame}
\frametitle{Konstanten}
\begin{block}{\vspace*{-3ex}}
%\begin{itemize}
%  \item Konstanten sind Funktionen ohne Parameter
%\end{itemize}
Konstanten sind Funktionen ohne Parameter
\end{block}
\end{frame}

\subsection{Ausdrücke}
\begin{frame}
\frametitle{Ausdrücke}
\begin{block}{\vspace*{-3ex}}
elementare Ausdrücke bzw. Grundterme setzten sich zusammen aus:
\begin{itemize}
  \item Konstanten wie z.B. Zahlen (\lstinline|10|, \lstinline|9.8|), Zeichen (\lstinline|'a'|, \lstinline|'Z'|), \ldots
  \item Andere Funktionen \lstinline|sin|, \lstinline|+|, \lstinline|*|, \ldots
\end{itemize}
\end{block}
\begin{alertblock}{Infixnotation}
Funktionszeichen: \lstinline|3 + 4| $\equiv$ \lstinline|(+) 3 4|\\
Funktionsname: \lstinline|mod 100 4| $\equiv$ \lstinline|100 `mod` 4|
\end{alertblock}
\end{frame}

\begin{frame}
\frametitle{Ausdrücke}
\begin{block}{\vspace*{-3ex}}
\begin{itemize}
  \item Elementare Ausdrücke mit Variablen sind Ausdrücke bzw. Terme
  \item Durch einen "`Vorspann"' wie $\ x$ wird die Variable $x$ mit der $\lambda$-Notation "`gebunden"'
  \item $\lambda a \to \lambda b \to a + b$ ist ein $\lambda$-Ausdruck
  \item $\lambda$ ist kein ASCII Zeichen, deswegen wird "`\textbackslash"' verwendet 
\end{itemize}
\end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{Ausdrücke} 
\begin{exampleblock}{Elementarer Ausdruck}
\lstinline|plus = 10 + 30|
\end{exampleblock}
\begin{exampleblock}{Ausdruck}
\lstinline|plus' a b = a + b|
\end{exampleblock}
\begin{exampleblock}{Lambda ($\lambda$)-Ausdruck}
\lstinline|plus'' =  \\a -> \\b -> a + b|\\
Morgen kommt mehr zum Thema $\lambda$-Ausdrücke
\end{exampleblock}
\end{frame}

\subsection{Funktionen}
\begin{frame}
\frametitle{Deklaration von Funktionen}
\begin{block}{\vspace*{-3ex}}
\begin{itemize}
  \item Funktion $f$ ist ein Tripel $(D_f, W_f, R_f)$
  \item $D_f$ Definitionsmenge
  \item $W_f$ Wertemenge
  \item $R_f \subseteq D_f \times W_f$
  \item $R_f$ muss \textbf{rechtseindeutig} sein d.h. es gibt keine zwei Paare $(a,b1) \in R_f$ und $(a,b_2) \in R_f$ mit $b_1 \neq b_2$
  \item Somit gilt, eine Funktion $f$ bildet den Argumentwert $x$ in den Resultatwert $y$ ab 
\end{itemize}
\end{block}
\end{frame}

\begin{frame}
\frametitle{Deklaration von Funktionen}
\only<1>{
\vspace*{-1ex}
\begin{exampleblock}{Konstante}
\begin{center}
\scalebox{0.6}{\input{images/Konstante.tex}}
\end{center}
\end{exampleblock}}
\only<2>{
\vspace*{-1ex}
\begin{exampleblock}{Funktion}
\begin{center}
\scalebox{0.5}{\input{images/Funktion.tex}}
\end{center}
\end{exampleblock}}
\only<3>{\begin{exampleblock}{Allgemein}
\begin{center}
\scalebox{0.6}{\input{images/FunktionAlg.tex}}
\end{center}
\end{exampleblock}}
\only<1-2>{\vspace*{-3ex}
\begin{block}{\vspace*{-3ex}}
\begin{itemize} 
  \item Funktionsköpfe sind optional, jedoch empfohlen
  \item Funktionsnamen beginnen mit Kleinbuchstaben
  \item Parameter von Funktionen beginnen mit Kleinbuchstaben
\end{itemize}
\end{block}}
\end{frame}

\begin{frame}[fragile]
\frametitle{Deklaration von Funktionen} 
\begin{exampleblock}{Konstante}
\begin{lstlisting}
eins :: Int
eins  = 1
\end{lstlisting}
\end{exampleblock}
\end{frame}

\begin{frame}[fragile]
\frametitle{Deklaration von Funktionen} 
\begin{exampleblock}{Konstante}
\begin{lstlisting}
eins :: Int
eins  = 1
\end{lstlisting}
\end{exampleblock}
\begin{exampleblock}{Unäre Funktion}
\begin{lstlisting}
successor :: Int -> Int
successor      a  = a + 1
\end{lstlisting}
\end{exampleblock}
\end{frame}

\begin{frame}[fragile]
\frametitle{Deklaration von Funktionen} 
\vspace*{-2.5ex}
\begin{exampleblock}{Konstante}
\begin{lstlisting}
eins :: Int
eins  = 1
\end{lstlisting}
\end{exampleblock}
\vspace*{-3ex}
\begin{exampleblock}{Unäre Funktion}
\begin{lstlisting}
successor :: Int -> Int
successor      a  = a + 1
\end{lstlisting}
\end{exampleblock}
\vspace*{-3ex}
\begin{exampleblock}{Binäre Funktion}
\begin{lstlisting}
nimmDenZweiten :: Int -> Int -> Int
nimmDenZweiten    _      b    = b
\end{lstlisting}
\end{exampleblock}
\end{frame}

\begin{frame}
\frametitle{Funktionen vs. Operatoren}
\begin{block}{\vspace*{-3ex}}
\begin{itemize}
  \item Funktionen besitzen einen Namen aus Buchstaben
  \item Operatoren besitzen einen Namen aus Zeichen
  \item Funktionen binden stärker als Operatoren (Standard)
  \item Operatoren werden wie Funktionen deklariert
\end{itemize}
\end{block}
\end{frame}

\subsection{Blöcke}
\begin{frame}
\frametitle{Der where Block}
\vspace*{-3ex}
\begin{block}{\vspace*{-3ex}}
\begin{itemize}
  \item Zur nachträglichen Definition von internen Hilfsfunktionen (Teilfunktionen)
  %\item {}<ober Funktion> \dots = <Hilfsfunktion> + <Ausdruck> \\ \textbf{where} \\ <Hilfsfunktion> \dots = \dots
  \item Verschachtelung erlaubt
  \item Definiert für die ganze Funktion
  \item "`Funktionsköpfe"' erlaubt
\end{itemize}
\end{block}
\only<2>{
\vspace*{-2ex}
	\begin{exampleblock}{\vspace*{-3ex}}
	\begin{center}
	\vspace*{-2ex}
	\scalebox{0.45}{\input{images/BlockWhere.tex}}
	\end{center}
	\end{exampleblock}
}
\end{frame}

\begin{frame}[fragile]
\frametitle{Der where Block}
\begin{lstlisting}
dec a = inc a - 2
    where	
        inc a = a + 1
\end{lstlisting}
\begin{exampleblock}{\vspace*{-3ex}}
\begin{center}
\vspace*{-1ex}
\scalebox{0.45}{\input{images/BlockWhere.tex}}
\end{center}
\end{exampleblock}
\end{frame}

\begin{frame}[fragile]
\frametitle{Der where Block}
\begin{lstlisting}
f :: Int -> Int 
f   a   = x a `div` 3
    where x b = y b * 2
        where y b = a + b + 1 
\end{lstlisting}
\only<1>{
\begin{exampleblock}{\vspace*{-3ex}}
\begin{center}
\vspace*{-1ex}
\scalebox{0.45}{\input{images/BlockWhere.tex}}
\end{center}
\end{exampleblock}}
\only<2-3>{
\begin{exampleblock}{Aufruf}
\lstinline|f 4|
\end{exampleblock}}
\only<3>{
\begin{exampleblock}{Ausgabe}
\lstinline|6|
\end{exampleblock}}
\end{frame}

\begin{frame}
\frametitle{Der let-in Block}
\only<1>{\begin{block}{\vspace*{-3ex}}
\begin{itemize}
  \item Zur vorherigen Definition von internen Hilfsfunktionen (Teilfunktionen)
  %\item {[} <ober Funktion> \dots = {]} \\ \textbf{let} <Hilfsfunktion> \dots = \dots \\ {[}\textbf{in} 
  % <Hilfsfunktion> + <Ausdruck> {]}
  \item Kann auch zur Definition von Funktionen im Interpreter verwendet werden  
  \item Verschachtelung erlaubt
  \item Definiert für den Funktionsabschnitt 
\end{itemize}
\end{block}}
\only<2>{\begin{exampleblock}{\vspace*{-3ex}}
\begin{center}
\scalebox{0.45}{\input{images/BlockLet.tex}}\\
Blöcke mit let-in können verschachtelt sein\\
Bei mehr als einer Hilfsfunktion, muss nach dem \lstinline|let| ein Zeilenumbruch erfolgen.
\end{center}
\end{exampleblock}}
\end{frame}

\begin{frame}[fragile]
\frametitle{Der let-in Block}
\begin{lstlisting}
dec a = 
  let               
      inc1 a = a + 1
      inc2 a = a + 2
  in  inc1 a - inc2 0
\end{lstlisting}
\only<1>{\begin{exampleblock}{Zur Definition von Funktionen direkt im GHCi}
\lstinline|let {plus :: Int -> Int -> Int; plus a b = a + b}|
\end{exampleblock}}
\only<2-3>{
\begin{exampleblock}{Aufruf}
\lstinline|dec 42|
\end{exampleblock}}
\only<3>{
\begin{exampleblock}{Ausgabe}
\lstinline|41|
\end{exampleblock}}
\end{frame}

\begin{frame}[fragile]
\frametitle{Der let-in Block}
\begin{lstlisting}
outer a = 
    let mid b = 
        let inner c = c + 1
        in inner b + 2
    in mid a + 3	
\end{lstlisting}
\only<1-2>{
\begin{exampleblock}{Aufruf}
\lstinline|outer 42|
\end{exampleblock}}
\only<2>{
\begin{exampleblock}{Ausgabe}
\lstinline|48|
\end{exampleblock}}
\end{frame}

\section{Einfache Datentypen}
\begin{frame}
\frametitle{Einfache Datentypen}
\begin{block}{\vspace*{-3ex}}
\begin{itemize}
  \item \lstinline|Bool|
  \item \lstinline|Int|
  \item \lstinline|Integer|
  \item \lstinline|Float|
  \item \lstinline|Double|
  \item \lstinline|Char|
\end{itemize}
\end{block}
\end{frame}
\subsection{Warheitswerte}
\begin{frame}
\frametitle{\lstinline|Bool|}
\begin{block}{\vspace*{-3ex}}
\begin{itemize}
  \item Einfacher Wahrheitswert
  \item \lstinline|True| oder \lstinline|False|
  \item \lstinline|not| $\equiv$ Verneinung
  \item \lstinline|&&| (binär), \lstinline|and| (Liste) $\equiv$ und
  \item \lstinline!||! (binär), \lstinline|or| (Liste) $\equiv$ oder
  \item \lstinline|==| $\equiv$ gleich
  \item \lstinline|/=| $\equiv$ ungleich
\end{itemize}
\end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{\lstinline|Bool|} 
\begin{lstlisting}
myAnd :: Bool -> Bool -> Bool
myAnd True True  = True
myAnd _    _     = False

myOr :: Bool -> Bool -> Bool
myOr False False = False
myOr _     _     = True
\end{lstlisting}
\end{frame}
\subsection{Ganzzahlen}
\begin{frame}
\frametitle{\lstinline|Int|}
\begin{block}{\vspace*{-3ex}}
\begin{itemize}
  \item 32 Bit Ganzzahl (Architektur abhängig)
  \item Min = $-2^{31} = -2147483648$
  \item Max = $2^{31} - 1 = 2147483647$
  \item Zirkulär $(2^{31} - 1) + 1 = -2^{31}$ 
\end{itemize}
\end{block}
\begin{alertblock}{Achtung}
\lstinline|Int| ist nicht gleich \lstinline|Integer|!
\end{alertblock}
\end{frame}

\begin{frame}
\frametitle{\lstinline|Integer|}
\begin{block}{\vspace*{-3ex}}
\begin{itemize}
  \item Unbegrenzte Ganzzahl (RAM Größe ist die "`Begrenzung"')
  \item Bei unendlich Arbeitsspeicher wirklich unbegrenzt
\end{itemize}
\end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{\lstinline|Int| vs \lstinline|Integer|} 
\begin{lstlisting}
plus :: Int -> Int -> Int
plus a b = a + b
\end{lstlisting}
\only<1-2>{
\begin{exampleblock}{Aufruf}
\lstinline|plus 2147483647 1|
\end{exampleblock}}
\only<2>{
\begin{exampleblock}{Ausgabe}
\lstinline|-2147483648|
\end{exampleblock}}
\end{frame}

\begin{frame}[fragile]
\frametitle{\lstinline|Int| vs \lstinline|Integer|} 
\begin{lstlisting}
plus' :: Integer -> Integer -> Integer
plus' a b = a + b
\end{lstlisting}
\only<1-2>{
\begin{exampleblock}{Aufruf}
\lstinline|plus' 9876543210 9876543210|
\end{exampleblock}}
\only<2>{
\begin{exampleblock}{Ausgabe}
\lstinline|19753086420|
\end{exampleblock}}
\only<3-4>{
\begin{exampleblock}{Aufruf}
\lstinline|plus' 99999999999999999999 99999999999999999999|
\end{exampleblock}}
\only<4>{
\begin{exampleblock}{Ausgabe}
\lstinline|199999999999999999998|
\end{exampleblock}}
\end{frame}

\begin{frame}[fragile]
\frametitle{\lstinline|Int| vs \lstinline|Integer|} 
\begin{lstlisting}
id :: Int -> Integer
id a = a

id' :: Integer -> Int
id' a = a
\end{lstlisting}
\begin{alertblock}{Geht nicht}
Auch wenn \lstinline|Int| für uns eine Teilmenge von \lstinline|Integer| ist.
\end{alertblock}
\end{frame}

\begin{frame}[fragile]
\frametitle{\lstinline|Int| vs \lstinline|Integer|} 
\begin{lstlisting}
plus :: Integer -> Int -> Integer
plus a 0 = a
plus a b = plus (a + 1) (b - 1)

plus' :: Int -> Integer -> Int
plus' a 0 = a
plus' a b = plus' (a + 1) (b - 1)
\end{lstlisting}
\begin{alertblock}{Geht}
Jedoch hat dies nichts mit interner Typkompatibilität zu tun.
\end{alertblock}
\end{frame}

\subsection{Gleitkommazahl}
\begin{frame}
\frametitle{\lstinline|Float| - \lstinline|Double|}
\begin{block}{\vspace*{-3ex}}
\begin{itemize}
  \item \lstinline|Float| 32 Bit Gleitkommazahl 
  \item \lstinline|Double| 64 Bit Gleitkommazahl
  \item \lstinline|Float| und \lstinline|Double| sind ebenfalls inkompatibel zueinander wie \lstinline|Int| und \lstinline|Integer|
\end{itemize}
\end{block}
\end{frame}

\subsection{Zeichen}
\begin{frame}
\frametitle{\lstinline|Char|}
\begin{block}{\vspace*{-3ex}}
\begin{itemize}
  \item Stellt jedes Zeichen des Unicode (ISO 10646) da
  \item Geordnet nach der Reihenfolge des Auftretens
\end{itemize}
\end{block}
\end{frame}